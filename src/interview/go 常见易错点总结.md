### 关闭 HTTP 连接
一些支持 HTTP1.1 或 HTTP1.0 配置了 connection:keep-alive选项的服务器会保持一段时间的长连接。但标准库"net/http"的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后：
1. **直接设置请求变量的 Close 字段值为 true**，每次请求结束后就会主动关闭连接。
2. 设置 **Header 请求头部选项 Connection: close**，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。

---------------------

### 实际编码常常会遇到的问题

- `for range`
- 数组是值传递
- `recover` 必须在`defer`函数中运行
- 在 `encode/decode JSON` 数据时，`Go` 默认会将数值当做 `float64` 处理
- 切片会导致整个底层数组被锁定, 底层数组无法释放内存. 如果底层数组较大会对内存产生很大的压力.
- Go 语言中对象的地址可能发生变化, 因此指针不能从其它非指针类型的值生成
- `mgo`的`copy()`方法与`clone()`方法【`clon()`适合快速写入，可是对于大开销、复杂查询应付不过来。】
- `time`包要使用与标准库一直的时间常量，否则可能时间错乱。
- 接口设计误区：一个包里面有很多个接口，而每个接口只有不多的方法【增加运行时开销】
- “生产者/消费者”模型中由消费者关闭`channel`，容易造成`goroutine`泄露
- 自定义类型的`String()`方法虽好不涉及`string`的方法，会导致意料之外的错误。
- rpc调用看不到源码，**出现问题的时候很难还原真实的调用栈。**
- 关闭 HTTP 的响应体( `defer resp.Body.Close()`)，避免发生内存泄露
