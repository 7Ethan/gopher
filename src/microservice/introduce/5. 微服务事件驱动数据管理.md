## 微服务和分布式数据管理问题

当我们转向微服务架构时，数据访问将变得非常复杂。因为每个微服务所拥有的数据对当前微服务来说是私有的，只能通过其提供的 API 进行访问。

如果多个服务访问相同的数据，模式（schema）更新需要对所有服务进行耗时、协调的更新。更糟糕的是，不同的微服务经常使用不同类型的数据库。


现代应用程序存储和处理着各种数据，而关系型数据库并不总是最佳选择。在某些场景，特定的 NoSQL 数据库可能具有更方便的数据模型，提供了更好的性能和可扩展性。基于微服务的应用程序通常混合使用 SQL 和 NoSQL 数据库，即所谓的混合持久化（polyglot persistence）方式。

分区的数据存储混合持久化架构具有许多优点，包括了松耦合的服务以及更好的性能与可扩展性。然而，它也引入了一些分布式数据管理方面的挑战:

1. 第一个挑战是如何实现业务的事务在多个服务之间保持一致性。(两阶段提交（2PC）)
2. 第二个挑战是如何实现从多个服务中检索数据。


## 事件驱动架构

在此架构中，微服务在发生某些重要事件时发布一个事件。其他微服务订阅了这些事件，当微服务接收到一个事件时，它可以更新自己的业务实体，这可能**导致更多的事件被发布**。

您可以使用事件实现跨多服务的业务的事务。一个事务由一系列的步骤组成。每个步骤包括了微服务更新业务实体和发布一个事件来触发下一步骤。

事件驱动的架构优点:
1. 它能够实现跨越多服务并提供最终一致性的事务。
2. 另一个好处是它还使得应用程序能够维护物化视图。

quedian:
1. 一个缺点是其编程模型比使用 ACID 事务更加复杂。
2. 应用程序必须处理不一致的数据。
3. 另一个缺点是订阅者必须要检测和忽略重复的事件。


## 实现原子性
在事件驱动架构中，同样存在着原子更新数据库和发布事件相关问题。

### 1.使用本地事务发布事件
实现原子性的一种方式是应用程序使用**仅涉及本地事务的多步骤过程**来发布事件。

诀窍在于存储业务实体状态的数据库中有一个用作消息队列的 EVENT 表。应用程序开启一个（本地）数据库事务，更新业务实体状态，将事件插入到 EVENT 表中，之后提交事务。一个单独的应用程序线程或进程查询 EVENT 表，将事件发布到 Message Broker，然后使用本地事务将事件标记为已发布。

这种方法的缺点是它很容易出错，因为开发人员必须要**记得发布事件**。这种方法的局限性在于，由于其有限的事务和查询功能，**在使用某些 NoSQL 数据库时，实现起来将是一大挑战**。


### 2.挖掘数据库事务日志

用一个对数据库的事务或者提交日志进行挖掘的线程或进程来发布事件,shi实现原子性的另一种方式。

shixianfangshi:当应用程序更新数据库时，更改信息被记录到数据库的事务日志中。事务日志挖掘器（Transaction Log Miner） 线程或进程读取事务日志并向 Message Broker 发布事件。

### **3.使用事件溯源**
事件溯源通过使用不同于之前的、以事件为中心的方式来持久化业务实体，**实现无 2PC 原子性**。

shixianyuanli:。应用程序不存储实体的当前状态，而是存储一系列状态改变事件。应用程序通过回放事件来重建实体的当前状态。无论业务实体的状态何时发生变化，其都会将新事件追加到事件列表中。由于保存事件是一个单一操作，因此具有原子性。

事件被持久化在事件存储中，事件存储是一个事件的数据库。该存储有一个用于添加和检索实体事件的 API。事件存储还与我们之前描述的架构中的 Message Broker 类似。它提供了一个 API，使得服务能够订阅事件。事件存储向所有感兴趣的订阅者派发所有事件。**可以说事件存储是事件驱动微服务架构的支柱**。

事件溯源解决了实现事件驱动架构的关键问题之一，**可以在状态发生变化时可靠地发布事件**。因此，它解决了微服
务架构中的数据一致性问题。业务逻辑包括松耦合的交换事件业务实体，这使得从单体应用程序迁移到微服务架构将变得更加容易。

事件存储仅支持通过主键查找业务实体。必须使用命令查询责任分离（CQRS）来实现查询。因此，应用程序必须处理最
终一致的数据。

## 总结

在微服务架构中，每个微服务都有私有的数据存储。不同的微服务可能会使用不同的 SQL 或者 NoSQL 数据库。虽然这种数据库架构具有明显的优势，但它创造了一些分布式数据管理挑战。第一个挑战是如何实现维护多个服务间的业务事务一致性。第二个挑战是如何实现从多个服务中检索数据。

大部分应用使用的解决方案是事件驱动架构。实现事件驱动架构的一个挑战是如何以原子的方式更新状态以及如何发布事件。有几种方法可以实现这点，包括了将数据库作为消息队列、事务日志挖掘和事件溯源。