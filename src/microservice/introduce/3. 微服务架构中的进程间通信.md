服务必须使用进程间通信（IPC）机制进行交互。

## 交互方式

* 同步 — 客户端要求服务及时响应，在等待过程中可能会发生阻
塞。
* 异步 — 客户端在等待响应时不会发生阻塞，但响应（如果有）不一定立即返回。

-----

一对一交互分为以下列举的类型，包括同步（请求/响应）与异步（通知与请求/异步响应）：

* 请求/响应

>户端向服务发出请求并等待响应。客户端要求响应及时到达。在基于线程的应用程序中，发出请求的线程可能在等待时

* 发生阻塞。
>知（又称为单向请求）客户端向服务发送请求，但不要求响应。

* 请求/异步响应
>户端向服务发送请求，服务异步响应。客户端在等待时不发生阻止，适用于假设响应可能不会立即到达的场景。

-----

一对多交互可分为以下列举的类型，它们都是异步的：

* 发布/订阅

>户端发布通知消息，由零个或多个感兴趣的服务消费。
* 发布/异步响应

>户端发布请求消息，之后等待一定时间来接收消费者的响应。


## 定义 API

服务 API 是服务与客户端之间的契约。无论您选择何种 IPC 机制，使用接口定义语言（interface definition language，IDL）来严格定义服务API都是非常有必要的。


eg:

* 如果您正在使用消息传递，那么 API 是由消息通道和消息类型组成。
* 如果您使用的是 HTTP，那么 API 是由 URL、请求和响应格式组成。


## 演化 API

可能需要逐步部署服务的新版本，以便新旧版本的服务同时运行。因此，制定更改API的处理策略还是很重要的。

处理 API 变更的方式取决于变更的程度:

1. 某些更改是次要或需要向后兼容以前的版本。

如，向请求或响应添加属性:此时设计客户端与服务遵守鲁棒性原则就显得很有意义了...



2. 须对 API 作出大量不兼容的更改

由于无法强制客户端立即升级，服务也必须支持较旧版本的 API 一段时间。如果使用了基于HTTP的机制（如 REST），则一种方法是将版本号嵌入到URL中。每个服务实例可能同时处理多个版本。或者，可以部署多个不同的实例，每个实例用于处理特定版本。

### 处理局部故障

在分布式系统中始终存在局部故障的风险。

处理局部故障的策略包括：

* 网络超时

在等待响应时，不要无限期地阻塞，始终使用超时方案。使用
超时方案确保资源不被无限地消耗。

* 限制未完成的请求数量

对客户端请求的特定服务，设置未完成请求的数量上限。如果达到了上限，发出的额外请求可能是毫无意义的，因此这些尝试需要立即失败。

* 断路器模式

追踪成功和失败请求的数量。如果错误率超过配置阈值，则断开断路器，以便后续的尝试能立即失败。如果出现大量请求失败，则表明服务不可用，发送请求将是无意义的。发生超时后，客户端应重新尝试，如果成功，则关闭断路器。

* 提供回退

请求失败时执行回退逻辑。例如，返回缓存数据或者默认值，如一组空白的推荐数据。

## IPC 技术

服务可以使用基于同步请求/响应的通信机制，比如基于HTTP的REST或Thrift。或者，可以使用异步、基于消息的通信机制，如AMQP或STOMP.

服务可以使用可读的、基于文本的格式，如 JSON 或 XML。或者，可以使用如Avro或Protocol  Buffers 等二进制格式（更加高效）。

### 异步、基于消息的通信

当使用消息传递时，进程通过异步交换消息进行通信。

由于通信是异步的，因此客户端不会阻塞等待回复。相反，客户端被假定不会立即收到回复。

一条消息由头部（如发件人之类的元数据）和消息体组成。消息通过通道进行交换。任何数量的生产者都可以向通道发送消息，任何数量的消费者都可以从通道接收消息。

有两种通道类型，分别是点对点（point‑to‑point）与发布订阅（publish‑subscribe）：

* 点对点通道发送一条消息给一个切确的、正在从通道读取消息的消费者。服务使用点对点通道，就是上述的一对一交互方式。

* 发布订阅通道将每条消息传递给所有已订阅的消费者。服务使用发布订阅通道，就是上述的一对多交互方式。


有大量的开源消息系统可供选择，包括RabbitMQ,Apache,Kafka、Apache ActiveMQ 和 NSQ。


使用消息传递优点：
1. 将客户端与服务分离
2. 消息缓冲
3. 灵活的客户端 — 服务交互

缺点:
1. 额外的复杂操作
2. 实现基于请求/响应式交互的复杂性


### 同步的请求/响应 IPC

当使用基于同步、基于请求/响应的IPC机制时，客户端向服务器发送请求,与使用消息传递不同，客户端假
定响应能及时到达。

#### REST

REST 是一种使用了HTTP（几乎总是）的 IPC 机制。

Leonard Richardson 定义了一个非常有用的 REST 成熟度模型，包括
以下层次：

- 级别 0
  
级别 0 的 API 的客户端通过向其唯一的 URL 端点发送 HTTP POST 请求来调用该服务。每个请求被指定要执行的操作、操作的目标（如业务对象）以及参数。

- 级别 1

级别 1 的 API 支持资源概念。要对资源执行操作，客户端会创建一个 POST 请求，指定要执行的操作和参数。

- 级别 2

级别 2 的 API 使用 HTTP 动词（谓词）执行操作：使用 GET 检索、使用 POST 创建和使用 PUT 进行更新。请求查询参数和请求体（如果有）指定操作的参数。这使服务能够利用得到 Web 的基础特性，如缓存 GET 请求。

- 级别 3

级别 3 的 API 基于非常规命名原则设计，HATEOAS（Hypermedia as the engine of application state，超媒体即应用程序状态引擎）。基本思想是 GET 请求返回的资源的表述，包含用于执行该资源上允许的操作的链接。

HATEOAS 的一个好处是不再需要将 URL 硬编码在客户端代码中。另一个好处是，由于资源的表示包含可允许操作的链接，所以客户端不必猜测可以对当前状态的资源执行什么操作。


使用 HTTP de缺点：

1. HTTP 仅直接支持请求/响应的交互方式。可以使用 HTTP 进行通知，但服务器必须始终发送 HTTP 响应。
2. 因为客户端和服务直接通信（没有一个中间者来缓冲消息），所以它们必须在交换期间都运行着。
3. 客户端必须知道每个服务实例的位置（即 URL）。如第二章关于 API 网关所述，这是现代应用程序中的一个复杂问题。


#### Thrift

它是一个用于编写跨语言 RPC 客户端和服务器框架.。Thrift 提供了一个 C 风格的 IDL来定义您的 API。您可以使用 Thrift 编译器生成客户端 stub 和服务器端 skeleton。编译器可以生成各种语言的代码.

Thrift 支持多种消息格式：JSON，二进制和压缩二进制。

Thrift 还提供了包括原始 TCP 和 HTTP 在内的传输协议选择。

#### 消息格式

如果您使用的是消息系统或 REST，则可以选择自己的消息格式。

其他 IPC 机制如 Thrift 使用跨语言的消息格式很重要,有两种主要的消息格式：文本和二进制。

- 基于文本格式的例子有JSON 和 XML(人类可读,自描述)。
- 二进制格式:Thrift 的二进制格式,Protocol Buffers 和 Apache Avro。  

## 总结

服务必须使用进程间通信机制进行通信。在设计服务如何进行通信时，您需要考虑各种问题：服务如何交互、如何为每个服务指定API、如何演变 API 以及如何处理局部故障。微服务可以使用两种IPC 机制：异步消息传递和同步请求/响应。为了进行通信，一个服务必须能够找到另一个服务。

