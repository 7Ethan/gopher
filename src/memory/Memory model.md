## golang的内存模型。

**++Go内存模型规范了在什么条件下一个Goroutine对某个变量的修改一定对其它Goroutine可见++。**

内存模型和对象模型是不同的。**对象模型说的是一个对象是如何被设计的**，其在内存中是如何布局的。而**内存模型说的是，在多核多线程环境下，各种不同的CPU是如何以一种统一的方式来与内存交互的**。

#### 背景知识：CPU的高速缓存

总所周知，CPU和内存并不是直接交换数据的，它们之间还隔着一个**高速缓存**。

高速缓存是对程序员透明的，这意味在编程的时候是感知不到CPU的缓存的存在的。一般情况下确实如此，但在，在**某些特殊的情形下（多核多线程），就不能忽略缓存的存在了**。这其实是和缓存的设计有关系，一般多处理器下的每个CPU都有一个自己的缓存，存储在这个缓存的数据是其它CPU是无法查看的。

#### 内存模型是什么

首先，残酷的现实就是每个CPU设计都是不同的，每个CPU对指令乱序的程度也是不一样的。比较保守的如x86仅会对Store Load乱序，但是一些优化激进的CPU（PS的Power）会允许更多情况的乱序产生。

如果目标是写一个跨平台多线程的程序，那么势必要了解每一个CPU的细节，来插入确切的、足够的内存屏障来保证程序的正确性。这是多么的不科学啊！科学的做法应该是，我为一个抽象的机器写一套抽象的程序，然后在不同的平台下让编程语言、编译器来生成合适的内存屏障。

因此，我们有了内存模型的概念。不同平台下的实现差别被统一的内存模型所隐藏，只需要根据这个抽象的内存模型来编写程序即可，这便是伟大的抽象...